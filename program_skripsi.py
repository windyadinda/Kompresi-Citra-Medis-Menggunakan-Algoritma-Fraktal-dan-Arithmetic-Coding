# -*- coding: utf-8 -*-
"""Program Skripsi

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jkBPvgWFhn_sVo5sIROXBp-PEMiqE96T

#General Function
"""

# init
import matplotlib.pyplot as plt #embuat plot dan visualisasi data
import matplotlib.image as mpimg #mengimpor dan memanipulasi gambar dalam plot matplotlib
from scipy import ndimage #untuk pemrosesan gambar seperti rotasi, transformasi, dan lainnya
from scipy import optimize #optimasi numerik, seperti pencarian nilai terbaik dalam fungsi
import numpy as np #operasi matematika, matriks, dan array.
import math

from PIL import Image #untuk memanipulasi gambar, seperti membuka, menyimpan, dan mengubah ukuran gambar.
import os #mengakses file dan direktori

import cv2 #olah image
from collections import Counter #tabel prob
from google.colab.patches import cv2_imshow #nampilin gambar


# General Func

def floorToDigit(x,n): #membulatkan bilangan sesuai dengan akurasi dipakai untuk membandingan nilai RMSE
  return math.floor(x * 10**n) / 10**n #x(bilangan) n(digit pembulatan)

def RMSE(obj, target):
  return np.sqrt(np.mean(np.square(target - obj)))

def RMSE_itr(iterations, target): #untuk menghitung RMSE per iterasi
  arr_RMSE = [];
  for iteration in iterations:
    rmse_ = RMSE(iteration, target);
    arr_RMSE.append(rmse_)
  return arr_RMSE

def select_RMSE(iterations, target): #menentukan RMSE yang paling mirip
  arr_RMSE = RMSE_itr(iterations, target)
  i = 0
  while True: #melihat iterasi keberapa hasilnya yang sama
    curr_RMSE = arr_RMSE[i];
    next_RMSE = arr_RMSE[i] if i == len(arr_RMSE) else arr_RMSE[i+1];
    i+=1;
    if floorToDigit(curr_RMSE,2) == floorToDigit(next_RMSE,2):
      break
  return i

  # PSNR
def PSNR(obj, target):
  C = np.max(target);
  MSE = np.mean(np.square(target - obj));
  return 10 * math.log10((C**2)/MSE);

"""# Fractal"""

# fractall start

# Manipulate channels
def get_greyscale_image(img): #untuk memastikan citranya apakah grayscale atau tidak
    return np.mean(img[:,:,:2], 2)

# Transformations
def reduce(img, factor): #factor untuk menentukan seberapa besar rangenya, semakin besar factornya maka hasil imagenya akan semakin buruk
    result = np.zeros((img.shape[0] // factor, img.shape[1] // factor))
    for i in range(result.shape[0]):
        for j in range(result.shape[1]):
            result[i,j] = np.mean(img[i*factor:(i+1)*factor,j*factor:(j+1)*factor])
    return result #bentuknya matriks

def rotate(img, angle):
    return ndimage.rotate(img, angle, reshape=False)

def flip(img, direction):
    return img[::direction,:]

def apply_transformation(img, direction, angle, contrast=1.0, brightness=0.0):
    return contrast*rotate(flip(img, direction), angle) + brightness

# Contrast and brightness
def find_contrast_and_brightness2(D, S):
    # Fit the contrast and the brightness
    A = np.concatenate((np.ones((S.size, 1)), np.reshape(S, (S.size, 1))), axis=1)  #digunakan untuk menggabungkan data, npones= matriks angka 1, s.size = panjangnya s dengan kolomnya np.reshape untuk ngubah bentuk dari S
    b = np.reshape(D, (D.size,)) #D=domain #S= citra yg udah diolah
    x, _, _, _ = np.linalg.lstsq(A, b)
    #x = optimize.lsq_linear(A, b, [(-np.inf, -2.0), (np.inf, 2.0)]).x
    return x[1], x[0] #output berupa regresi karena difungsi aslinya

# Compression for greyscale images
def generate_all_transformed_blocks(img, source_size, destination_size, step): #source dan destination bebas
    factor = source_size // destination_size #factor untuk reduce, source = citra awal, destination = citra akhir
    transformed_blocks = []
    for k in range((img.shape[0] - source_size) // step + 1): #k dan l untuk baris dan kolom
        for l in range((img.shape[1] - source_size) // step + 1):
            # Extract the source block and reduce it to the shape of a destination block
            #if (k==0) and (l==0):
              #print(img[k*step:k*step+source_size,l*step:l*step+source_size])
            S = reduce(img[k*step:k*step+source_size,l*step:l*step+source_size], factor) #hasil reduce, dari reduce yang dipilih
            # Generate all possible transformed blocks
            for direction, angle in candidates:
                transformed_blocks.append((k, l, direction, angle, apply_transformation(S, direction, angle))) #akan melakukan pencatatan parameter kedala variabe; transform blok, S= hasil  transformasi matriks
    return transformed_blocks

def compress(img, source_size, destination_size, step): #source_size = step
    transformations = []
    print(img.shape)
    transformed_blocks = generate_all_transformed_blocks(img, source_size, destination_size, step)
    i_count = img.shape[0] // destination_size
    j_count = img.shape[1] // destination_size
    for i in range(i_count):
        transformations.append([])
        for j in range(j_count):
            # print("{}/{} ; {}/{}".format(i, i_count, j, j_count))
            transformations[i].append(None)
            min_d = float('inf')
            # Extract the destination block
            D = img[i*destination_size:(i+1)*destination_size,j*destination_size:(j+1)*destination_size] #ekstrak domain dari image asli
            # Test all possible transformations and take the best one
            for k, l, direction, angle, S in transformed_blocks: #untuk melakukan perhitungan dibawahnya
                contrast, brightness = find_contrast_and_brightness2(D, S)
                S = contrast*S + brightness
                d = np.sum(np.square(D - S)) #D blok domain yang udah dibagi*blok range) #S = Blok domain yang udh diskalain
                if d < min_d:
                    min_d = d
                    transformations[i][j] = (k, l, direction, angle, contrast, brightness)
    return transformations

def decompress(transformations, source_size, destination_size, step, nb_iter=8): #nb_iter untuk minimal iterasi
    factor = source_size // destination_size
    height = len(transformations) * destination_size #besaran range yang dipake sebesar destination size
    width = len(transformations[0]) * destination_size  #transformation[0] ngambil ke dimensi selanjutnya
    iterations = [np.random.randint(0, 256, (height, width))] #iterasi pertama gambar random
    cur_img = np.zeros((height, width)) #membuat matriks baru isinya 0 sebesar heigh dan width
    for i_iter in range(nb_iter):
        # print(i_iter)
        for i in range(len(transformations)):
            for j in range(len(transformations[i])):
                # Apply transform
                # print(transformations[i][j]);
                k, l, flip, angle, contrast, brightness = transformations[i][j]
                S = reduce(iterations[-1][k*step:k*step+source_size,l*step:l*step+source_size], factor) #iterasi[-1] ngambil urutan terakhir kemudia di reduce sesuai faktor dan dimasukkan kedalam var S
                D = apply_transformation(S, flip, angle, contrast, brightness)
                cur_img[i*destination_size:(i+1)*destination_size,j*destination_size:(j+1)*destination_size] = D #manggil alamat tapi bentukannya range
        iterations.append(cur_img)
        cur_img = np.zeros((height, width))
    return iterations

# Plot
def plot_iterations(iterations, target=None):
    # Configure plot
    plt.figure()
    nb_row = math.ceil(np.sqrt(len(iterations)))
    nb_cols = nb_row
    # Plot
    for i, img in enumerate(iterations):
        plt.subplot(nb_row, nb_cols, i+1)
        plt.imshow(img, cmap='gray', vmin=0, vmax=255, interpolation='none')
        if target is None:
            plt.title(str(i))
        else:
            # Display the RMSE
            plt.title(str(i) + ' (' + '{0:.2f}'.format(np.sqrt(np.mean(np.square(target - img)))) + ')')
        frame = plt.gca()
        frame.axes.get_xaxis().set_visible(False)
        frame.axes.get_yaxis().set_visible(False)
    plt.tight_layout()

# Parameters
directions = [1, -1]
angles = [270]
candidates = [[direction, angle] for direction in directions for angle in angles]


#### End Of Fractall

"""# Arithmetic Coding"""

# Arithmetic
# encode
def encode_image(pixels, block_size, probs_limits, float_type='float64'):
    i = 0
    block = []
    blocks = []
    for pixel in pixels:
        i += 1
        block.append(pixel)
        if i % block_size == 0: #block_size besaran range
            blocks.append(block)
            block = []

    encoded_array = []
    encoded_array_limit = {}
    encoded_number = 0
    start = 0
    end = 0
    t_start = 0
    t_end = 0
    for i in range(len(blocks)):
        start = t_start = probs_limits[blocks[i][0]][0]
        end = t_end = probs_limits[blocks[i][0]][1]
        for pixel in blocks[i]:
            t_start = start + (end-start)*probs_limits[pixel][0]
            t_end = start + (end-start)*probs_limits[pixel][1]
            start = t_start
            end = t_end
        avg = (start+end)/2
        bins = ""
        for j in range(32):
            avg *= 2
            if int(avg) == 1:
                bins += "1"
            else:
                bins += "0"
            avg -= int(avg)

        encoded_array.append(bins[::-1])
        encoded_array_limit[bins] = start, end

    # I do not need to use float type (e.g. .astype(float_type)) because I am saving the encoded "binary" not the float number itself
    encoded_array = np.array(encoded_array)
    np.save("encoded_array.npy", encoded_array)
    print("[Arithmetic] Encoding: Done!")


  # decode

def decode_image(encoded_array_name, n, m, block_size, probs_limits, additional_pixels):
    encoded_array = np.load(encoded_array_name+".npy")
    decoded_array = []
    length = encoded_array.shape[0]
    for i in range(length):
        start = t_start = 0
        end = t_end = 1
        encoded_number = encoded_array[i]
        block = 0
        for j in range(32):
            if encoded_number[31-j] == "1":
                block += pow(2, -(j+1))
        for j in range(block_size):
            t_key = block
            if t_start != t_end:
                t_key = (block-t_start)/(t_end-t_start)

            # t_key = round(t_key, )

            prob = 0
            for key in probs_limits.keys():
                # print("KEYS")
                # print(t_key)
                # print(probs_limits[key][0])
                # print(probs_limits[key][1])
                if (t_key >= probs_limits[key][0]) and (t_key < probs_limits[key][1]):
                    # print("new key")
                    # print(key)
                    prob = key
                    break
            # print(prob)
            decoded_array.append(prob)
            t_start = start + (end-start)*probs_limits[prob][0]
            t_end = start + (end-start)*probs_limits[prob][1]
            start = t_start
            end = t_end
    while additional_pixels != 0: #additional_pixel untuk menambahkan 0 ke pixel aslinya agar bisa dibagi sesuai dengan block size
        decoded_array.remove(0)
        additional_pixels -= 1

    res = np.array(decoded_array).reshape(n, m)
    cv2.imwrite('result.jpg', res)
    print("[Arithmetic] Decoding: Done!")
    # cv2.imshow('result.jpg', res)
    plt.imshow(res, cmap='gray', interpolation='none')
    # cv2_imshow(res)
    # cv2.waitKey(0)  # waits until a key is pressed
    # cv2.destroyAllWindows()  # destroys the window showing image

    return res

"""# Perform Fractal"""

# Tests
def test_greyscale(origin_path):
    img = mpimg.imread(origin_path)
    img = get_greyscale_image(img) #ubah jadi image
    img = reduce(img, 2)

    nb_iter = 30; #menentukan iterasi
    # print(candidates)
    plt.figure()
    plt.imshow(img, cmap='gray', interpolation='none')
    transformations = compress(img, 8, 4, 8)

    # Convert the tuples into a sequence of symbols
    iterations = decompress(transformations, 8, 4, 8, nb_iter)

    # plt.figure()
    # plt.imshow(iterations[nb_iter], cmap='gray', interpolation='none')

    RMSE_index = select_RMSE(iterations, img);
    selected_result = iterations[RMSE_index];

    plot_iterations(iterations, img)

    plt.figure()
    plt.imshow(selected_result, cmap='gray', interpolation='none')

    #plt.show();
    print ("Iterasi", RMSE_index)
    return selected_result,img;
    for k in range((img.shape[0] - source_size) // step + 1):
        for l in range((img.shape[1] - source_size) // step + 1):
          if (k==0) and (l==0):
            print(img[k*step:k*step+source_size,l*step:l*step+source_size])

if __name__ == '__main__':

  origin_path = '/content/drive/MyDrive/SKRIPSI/dataset/1024_2.png'
  selected_result, img = test_greyscale(origin_path)
  #i = j = 0;
  #factor = 8;
  #ww = selected_result[i*factor:(i+1)*factor,j*factor:(j+1)*factor]

  #print(ww);

"""# Perform Arithmetic"""

# init perform test
# img_path = input("Enter image path: ")

img_ = selected_result
block_size = 2
n = img_.shape[0]
m = img_.shape[1]


# jsut to be sure that is the image is a grayscale
# gray = cv2.cvtColor(img_, cv2.COLOR_BGR2GRAY)
pixels = np.array(img_.flatten())
# pixels = matriks img


# append zeros to be divisible by the block_size
additional_pixels = 0
while pixels.shape[0] % block_size != 0:
    pixels = np.append(pixels, 0)
    additional_pixels += 1

length = pixels.shape[0] #lebar dri image dimasukkan ke length
freq = Counter(pixels) #library counter untuk ngitung
probs = {} #akan membuat objek
for key in freq.keys(): #key = simbol
    probs[key] = freq[key]/length

# frequecy table
start = 0
probs_limits = {} #prob limit yang isinya objek
for key in probs.keys(): #indeks key dalam tabel probs
    probs_limits[key] = start, start+probs[key] #manggil prob limit dengan alamat key= range high low
    start += probs[key] #nentukan range probabilitasnya low terbaru

np.save("probabilities.npy", probs_limits)
print("[Arithmetic] Processing input and calculating probabilities: Done!")

# perform encode
encode_image(pixels, block_size, probs_limits)

# additonal pixels is zeros to make the array divisible by block_size so I need to handle it in decoding also
ww = decode_image("encoded_array", n, m, block_size,probs_limits, additional_pixels)

print("PSNR:", PSNR(ww, img))
print("RMSE:", RMSE(ww, img))

def CR(obj_path, target_path):

  obj_size = os.stat(obj_path).st_size
  target_size = os.stat(target_path).st_size

  print("Citra Awal :", target_size)
  print("Citra Hasil :", obj_size)

  cr = target_size / obj_size
  return cr

print("CR :", CR('result.jpg', origin_path))